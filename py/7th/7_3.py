import numpy as np

n = 20
x = np.ones(n) / n  # начальное приближение x0
# Вычисляет вектор для данной системы уравнений.
def F(x):
    f = []
    # проходимся по массиву
    for i in range(len(x)):
        s = 0
        # перебераем все элементы вектора икс
        for xi in x:
            # вычисляем значение по формуле Ньютона 
            s += np.cos(xi) + 1j * (1 - np.cos(x[i])) - np.sin(x[i])
            # добовляем в переменную s
        f.append(s)
        return np.array(f) - len(x)

# Вычисляет матрицу Якоби  для данной системы уравнений.
def J(x):
    # определяем J  с аргументом x
    n = len(x)
    # создаем матрицу якоби заполненую нулями с типом комплексное число
    jac = np.zeros((n, n), dtype=complex)
    # проходимся по матрице и вычисляем элементы на главной диагонали а остальные вычисялются по формуле
    for i in range(n):
        for j in range(n):
            if i == j:
                # если это диагональный элемент то мы вычисляем частную производную i-го уравнения по i-ой переменной 
                jac[i][j] = 1j * np.sin(x[i]) - 1j * n * np.sin(x[i])
            else:
                # вычисляем по j-ой переменной производную если это не диагональ 
                jac[i][j] = -1j * np.sin(x[i])
    return jac


eps = 1e-6  # задаем точность
max_iter = 100  # задаем максимальное число итераций

# 
for i in range(max_iter):
    f = F(x)
    # проверяем проходит ли по погрешности
    if np.linalg.norm(f) < eps:
        break
    # если не проходит то находим вектор изменения dx  и обновляем x  для приближения к локальному оптимуму функции ( по примеру из учебника)
    dx = np.linalg.solve(J(x), -f)
    x += dx.real

print("Решение системы уравнений:")
print(x)
